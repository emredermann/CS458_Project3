"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSunAltitude = exports.getSunrise = exports.getQuantities = exports.getPhysicalSelenographicLocation = exports.getOpticalSelenographicLocation = exports.getSelenographicLocation = void 0;
var angleCalc_1 = require("../../utils/angleCalc");
var calculations_1 = require("../constants/calculations");
var sunCalc = __importStar(require("../../sun/calculations/sunCalc"));
var time_1 = require("../../time");
var createMoon_1 = __importDefault(require("../createMoon"));
var moonCalc_1 = require("./moonCalc");
function getSelenographicLocation(coords, T) {
    var _a = getOpticalSelenographicLocation(coords, T), lonOpt = _a.lon, latOpt = _a.lat;
    var _b = getPhysicalSelenographicLocation(coords, T), lonPhy = _b.lon, latPhy = _b.lat;
    return {
        lon: lonOpt + lonPhy,
        lat: latOpt + latPhy,
    };
}
exports.getSelenographicLocation = getSelenographicLocation;
function getOpticalSelenographicLocation(coords, T) {
    var F = (0, moonCalc_1.getArgumentOfLatitude)(T);
    var _a = getWA(coords, T), W = _a.W, A = _a.A;
    var latMoonRad = (0, angleCalc_1.deg2rad)(coords.lat);
    var WRad = (0, angleCalc_1.deg2rad)(W);
    var IRad = (0, angleCalc_1.deg2rad)(calculations_1.INCLINATION_OF_MEAN_LUNAR_EQUATOR);
    var lon = A - F;
    var latRad = Math.asin(-1 * Math.sin(WRad) * Math.cos(latMoonRad) * Math.sin(IRad) - Math.sin(latMoonRad) * Math.cos(IRad));
    var lat = (0, angleCalc_1.rad2deg)(latRad);
    return { lon: lon, lat: lat };
}
exports.getOpticalSelenographicLocation = getOpticalSelenographicLocation;
function getPhysicalSelenographicLocation(coords, T) {
    var latOpt = getOpticalSelenographicLocation(coords, T).lat;
    var A = getWA(coords, T).A;
    var _a = getQuantities(T), rho = _a.rho, sigma = _a.sigma, tau = _a.tau;
    var latOptRad = (0, angleCalc_1.deg2rad)(latOpt);
    var ARad = (0, angleCalc_1.deg2rad)(A);
    var lon = -1 * tau + (rho * Math.cos(ARad) + sigma * Math.sin(ARad)) * Math.tan(latOptRad);
    var lat = sigma * Math.cos(ARad) - rho * Math.sin(ARad);
    return { lon: lon, lat: lat };
}
exports.getPhysicalSelenographicLocation = getPhysicalSelenographicLocation;
function getQuantities(T) {
    var F = (0, moonCalc_1.getArgumentOfLatitude)(T);
    var D = (0, moonCalc_1.getMeanElongation)(T);
    var MSun = sunCalc.getMeanAnomaly(T);
    var MMoon = (0, moonCalc_1.getMeanAnomaly)(T);
    var O = (0, moonCalc_1.getMeanLongitudeOfAscendingNode)(T);
    var FRad = (0, angleCalc_1.deg2rad)(F);
    var DRad = (0, angleCalc_1.deg2rad)(D);
    var MSunRad = (0, angleCalc_1.deg2rad)(MSun);
    var MMoonRad = (0, angleCalc_1.deg2rad)(MMoon);
    var ORad = (0, angleCalc_1.deg2rad)(O);
    var K1 = 119.75 + 131.849 * T;
    var K2 = 72.56 + 20.186 * T;
    var K1Rad = (0, angleCalc_1.deg2rad)(K1);
    var K2Rad = (0, angleCalc_1.deg2rad)(K2);
    var E = 1 - 0.002516 * T - 0.0000074 * Math.pow(T, 2);
    var rho = -0.02752 * Math.cos(MMoonRad)
        - 0.02245 * Math.sin(FRad)
        + 0.00684 * Math.cos(MMoonRad - 2 * FRad)
        - 0.00293 * Math.cos(2 * FRad)
        - 0.00085 * Math.cos(2 * FRad - 2 * DRad)
        - 0.00054 * Math.cos(MMoonRad - 2 * DRad)
        - 0.00020 * Math.sin(MMoonRad + FRad)
        - 0.00020 * Math.cos(MMoonRad + 2 * FRad)
        - 0.00020 * Math.cos(MMoonRad - FRad)
        + 0.00014 * Math.cos(MMoonRad + 2 * FRad - 2 * DRad);
    var sigma = 0
        - 0.02816 * Math.sin(MMoonRad)
        + 0.02244 * Math.cos(FRad)
        - 0.00682 * Math.sin(MMoonRad - 2 * FRad)
        - 0.00279 * Math.sin(2 * FRad)
        - 0.00083 * Math.sin(2 * FRad - 2 * DRad)
        + 0.00069 * Math.sin(MMoonRad - 2 * DRad)
        + 0.00040 * Math.cos(MMoonRad + FRad)
        - 0.00025 * Math.sin(2 * MMoonRad)
        - 0.00023 * Math.sin(MMoonRad + 2 * FRad)
        + 0.00020 * Math.cos(MMoonRad - FRad)
        + 0.00019 * Math.sin(MMoonRad - FRad)
        + 0.00013 * Math.sin(MMoonRad + 2 * FRad - 2 * DRad)
        - 0.00010 * Math.cos(MMoonRad - 3 * FRad);
    var tau = 0.02520 * E * Math.sin(MSunRad)
        + 0.00473 * Math.sin(2 * MMoonRad - 2 * FRad)
        - 0.00467 * Math.sin(MMoonRad)
        + 0.00396 * Math.sin(K1Rad)
        + 0.00276 * Math.sin(2 * MMoonRad - 2 * DRad)
        + 0.00196 * Math.sin(ORad)
        - 0.00183 * Math.cos(MMoonRad - FRad)
        + 0.00115 * Math.sin(MMoonRad - 2 * DRad)
        - 0.00096 * Math.sin(MMoonRad - DRad)
        + 0.00046 * Math.sin(2 * FRad - 2 * DRad)
        - 0.00039 * Math.sin(MMoonRad - FRad)
        - 0.00032 * Math.sin(MMoonRad - MSunRad - DRad)
        + 0.00027 * Math.sin(2 * MMoonRad - MSunRad - 2 * DRad)
        + 0.00023 * Math.sin(K2Rad)
        - 0.00014 * Math.sin(2 * DRad)
        + 0.00014 * Math.cos(2 * MMoonRad - 2 * FRad)
        - 0.00012 * Math.sin(MMoonRad - 2 * FRad)
        - 0.00012 * Math.sin(2 * MMoonRad)
        + 0.00011 * Math.sin(2 * MMoonRad - 2 * MSunRad - 2 * DRad);
    return { rho: rho, sigma: sigma, tau: tau };
}
exports.getQuantities = getQuantities;
function getWA(coords, T) {
    var omega = (0, moonCalc_1.getMeanLongitudeOfAscendingNode)(T);
    var latMoonRad = (0, angleCalc_1.deg2rad)(coords.lat);
    var IRad = (0, angleCalc_1.deg2rad)(calculations_1.INCLINATION_OF_MEAN_LUNAR_EQUATOR);
    var W = (0, angleCalc_1.normalizeAngle)(coords.lon - omega);
    var WRad = (0, angleCalc_1.deg2rad)(W);
    var numerator = Math.sin(WRad) * Math.cos(latMoonRad) * Math.cos(IRad) - Math.sin(latMoonRad) * Math.sin(IRad);
    var denominator = Math.cos(WRad) * Math.cos(latMoonRad);
    var ARad = Math.atan2(numerator, denominator);
    var A = (0, angleCalc_1.normalizeAngle)((0, angleCalc_1.rad2deg)(ARad));
    return { W: W, A: A };
}
function getSunrise(selenographicLocation, T) {
    return __awaiter(this, void 0, void 0, function () {
        var h, _a, lon, lat, c0;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4, _getSelenographicLocationOfSun(T)];
                case 1:
                    _a = _b.sent(), lon = _a.lon, lat = _a.lat;
                    c0 = (0, angleCalc_1.normalizeAngle)(90 - lon);
                    h = getSunAltitude(selenographicLocation, lat, c0);
                    T -= _getCorrectionInDays(selenographicLocation, h) / 36525.0;
                    _b.label = 2;
                case 2:
                    if (Math.abs(h) > 0.001) return [3, 0];
                    _b.label = 3;
                case 3: return [2, T];
            }
        });
    });
}
exports.getSunrise = getSunrise;
function _getSelenographicLocationOfSun(T) {
    return __awaiter(this, void 0, void 0, function () {
        var toi, moon, coords;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    toi = time_1.createTimeOfInterest.fromJulianCenturiesJ2000(T);
                    moon = (0, createMoon_1.default)(toi);
                    return [4, moon.getHeliocentricEclipticSphericalDateCoordinates()];
                case 1:
                    coords = _a.sent();
                    return [2, getSelenographicLocation(coords, T)];
            }
        });
    });
}
function getSunAltitude(selenographicLocation, selenographicLatOfSun, c0) {
    var lon = selenographicLocation.lon, lat = selenographicLocation.lat;
    var lonRad = (0, angleCalc_1.deg2rad)(lon);
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var lat0Rad = (0, angleCalc_1.deg2rad)(selenographicLatOfSun);
    var c0Rad = (0, angleCalc_1.deg2rad)(c0);
    var hRad = Math.asin(Math.sin(lat0Rad) * Math.sin(latRad) + Math.cos(lat0Rad) * Math.cos(latRad) * Math.sin(c0Rad + lonRad));
    return (0, angleCalc_1.rad2deg)(hRad);
}
exports.getSunAltitude = getSunAltitude;
function _getCorrectionInDays(selenographicLocation, h) {
    var latRad = (0, angleCalc_1.deg2rad)(selenographicLocation.lat);
    return h / (12.19075 * Math.cos(latRad));
}
